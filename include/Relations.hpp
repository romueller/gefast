/*
 * GeFaST
 *
 * Copyright (C) 2016 - 2021 Robert Mueller
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Contact: Robert Mueller <romueller@techfak.uni-bielefeld.de>
 * Faculty of Technology, Bielefeld University,
 * PO box 100131, DE-33501 Bielefeld, Germany
 */

#ifndef GEFAST_RELATIONS_HPP
#define GEFAST_RELATIONS_HPP

#include <algorithm>

#include "Base.hpp"
#include "Utility.hpp"
#include "space/Basics.hpp"

namespace GeFaST {

    /*
     * Collection of (inverted) indices for the segment filter.
     * Each inverted index is a binary relation between segments (strings) and identifiers tailored to the case
     * that each identifier is related to exactly one string.
     *
     * When searching the identifiers related to a string and when removing the entries with a given identifier,
     * support data structures allow an almost direct access to the relation entries.
     *
     * The collection of indices is built for an amplicon pool and segment filters using a given number of segments.
     * The provided operations are also tailored to the use with the implemented segment filters in AuxiliaryData.
     * Therefore, some operations expect a certain order w.r.t. the provided parameters.
     * For example, when adding entries the identifiers are expected to be monotonically increasing.
     */
    class SegmentRelations {

        typedef std::unordered_map<numSeqs_t, numSeqs_t> length_map_type;
        typedef std::unordered_map<std::unique_ptr<SubstringWrapper>, std::vector<numSeqs_t>, hashSubstringWrapper, equalSubstringWrapper> sip_map_type;
        typedef sip_map_type::value_type* position_type;

    public:
        SegmentRelations(const AmpliconCollection& ac, numSeqs_t num_segs);

        ~SegmentRelations();

        SegmentRelations(const SegmentRelations& other); // copy constructor

        SegmentRelations(SegmentRelations&& other) noexcept; // move constructor

        SegmentRelations& operator=(const SegmentRelations& other); // copy assignment operator

        SegmentRelations& operator=(SegmentRelations&& other) noexcept; // move assignment operator

        // "count" the amplicons of the given length whose seg-th segment is equal to the given substring,
        // appends the ids of the found amplicons to the given vector
        // IMPORTANT: The existence of the length must be checked beforehand (or use add_counts_checked).
        void add_counts(const numSeqs_t len, const numSeqs_t seg, const std::unique_ptr<SubstringWrapper>& sip, std::vector<numSeqs_t>& cand_cnts);
        void add_counts_checked(const numSeqs_t len, const numSeqs_t seg, const std::unique_ptr<SubstringWrapper>& sip, std::vector<numSeqs_t>& cand_cnts);

        // "count" the amplicons of the given length whose seg-th segment is equal to the given substring
        // or the num_neigh next substrings generated by shifting to the right,
        // appends the ids of the found amplicons to the given vector
        // IMPORTANT: The existence of the length must be checked beforehand (or use add_counts_checked).
        void add_neighboured_counts(const numSeqs_t len, const numSeqs_t seg, std::unique_ptr<SubstringWrapper>& sip,
                                    numSeqs_t num_neigh, std::vector<numSeqs_t>& cand_cnts);
        void add_neighboured_counts_checked(const numSeqs_t len, const numSeqs_t seg, std::unique_ptr<SubstringWrapper>& sip,
                                            numSeqs_t num_neigh, std::vector<numSeqs_t>& cand_cnts);

        // inserts the given segment in the relation for the given length and segment number
        void record_segment(const numSeqs_t len, const numSeqs_t seg, const std::unique_ptr<SubstringWrapper>& sip, const numSeqs_t ampl_id);

        // remove the specified amplicon from all relations,
        // expects that only previously inserted identifiers are removed exactly once
        // and that the identifiers were inserted in ascending order
        void remove_amplicon(const numSeqs_t ampl_id);

        // check whether there are relations for the given length
        bool contains_length(const numSeqs_t len) const;

        /*
         * Determine the memory consumption (in bytes).
         */
        size_t size_in_bytes() const;

        /*
         * Show memory profile.
         */
        void show_memory() const;

    private:
        // array of mappings from SequenceWrapper to vector of ids,
        // contains a mapping for each observed sequence length and segment number,
        // mappings belonging to the same sequence length are stored consecutively
        sip_map_type* access_sip_;

        // mapping from sequence length to the first mapping in access_sip_ belonging to that length
        length_map_type access_len_;

        // given the pool-internal id of an amplicon and a segment number,
        // provides the index (in access_sip_) of the mapping containing the segment
        position_type* positions_;

        numSeqs_t pool_size_; // number of amplicons in the pool for which this relation has been built
        numSeqs_t num_segs_; // number of segments per sequence

    };

}

#endif //GEFAST_RELATIONS_HPP
